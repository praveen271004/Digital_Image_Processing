`timescale 1ns / 1ps

module design1 #(
    parameter t = 3
)(
    input clk,
    input rst,
    input wire [27:0] Syn,
    output reg [(4*(t+1))-1:0] sigma
);

    reg [3:0] d1 = 1;
    reg [3:0] h1 = 0;
    reg [3:0] A1 = -1;
    reg [3:0] sig1 = 1;   
    
    
    wire [3:0] S[6:0];
    
    reg [3:0] mu;
    reg [3:0] rho;
    reg [3:0] d[6:0];
    reg [3:0] h[6:0];
    reg [3:0] A[6:0];
    
    reg [3:0] max;
    reg [3:0] H;
    
    reg [3:0] sig[2*t:0][t:0];
    
    reg [3:0] alpha[6:0];
    reg [3:0] lamda[6:0];
    
    integer j;
    integer k;  
    integer l; 

    assign S[0] = Syn[3:0];
    assign S[1] = Syn[7:4];
    assign S[2] = Syn[11:8];  
    assign S[3] = Syn[15:12];
    assign S[4] = Syn[19:16];
    assign S[5] = Syn[23:20];
    assign S[6] = Syn[27:24];

    always @(posedge clk) begin 
         
         mu <= 0;
         d[0] <= S[1];
         h[0] <= 0;
         A[0] <= 0;
         max <= 0;
         rho <= 0;
         
         sig[0][0] <= 1;
         for (j = 1; j <= t; j = j + 1) begin
            sig[0][j] <= 0;
         end
         
         for (k = 0; k <= 2*t; k = k + 1) begin
         
             if (d[k] != 0) begin 
             
                 if (k == 0) begin 
                     d[k+1] <= S[2];
                     h[k+1] <= 1;
                     
                     A[k+1] <= 0;
                 
                     for (j = 0; j <= t; j = j + 1) begin
                         sig[k+1][j] <= sig[k][j];
                     end
                 end
                 else begin 
                 
//                    for (l = 0; l < k; l = l + 1) begin
//                         if(max < A[l])begin 
//                            max <= A[l];
//                            rho <= l;
//                         end 
//                    end
                    
//                    H <= h[rho] + k + rho; 
                    
//                    if(h[k] > H) begin 
//                        h[k+1] <= h[k];
//                    end 
//                    else begin 
//                        h[k+1] <= H;
//                    end 
                    
                    
                    d[k+1] <= d[k] + 1;
                    h[k+1] <= h[k] + 1;
                    A[k+1] <= (k+1) - h[k+1] ;
                     
                    for (j = 0; j <= t; j = j + 1) begin
                         sig[k+1][j] <= sig[k][j] + sig[k][j];
                    end
                 end
             end
             else begin 
                 d[k+1] <= d[k];
                 h[k+1] <= h[k];
                 A[k+1] <= (k+1) - h[k+1] ;
     
                 for (j = 0; j <= t; j = j + 1) begin
                     sig[k+1][j] <= sig[k][j];
                 end
             end
         
         end
    end
    
endmodule







/////////////////////////////////////////////test_bench////////////////////////////


/////////////////////////////////////////////test_bench////////////////////////////




`timescale 1ns / 1ps

module testbench;

    // Define parameters to match the DUT
    parameter t = 3;

    // Inputs to the DUT
    reg clk;
    reg rst;
    reg [27:0] Syn;

    // Outputs from the DUT
    wire [(4*(t+1))-1:0] sigma;

    // Instantiate the DUT
    design1 #(.t(t)) dut (
        .clk(clk),
        .rst(rst),
        .Syn(Syn),
        .sigma(sigma)
    );

    // Clock generation
    initial begin
        clk = 1;
        forever #5 clk = ~clk; // 10 ns period
    end

    // Test sequence
    initial begin
        // 1. Apply active-low reset
        rst = 1;        // assert reset
        Syn = 24'd0;
        #10;
        rst = 0;        // deassert reset
       

//        // 2. Provide a test pattern directly into Syn
//        Syn = {4'd0, 4'd2, 4'd1, 4'd1, 4'd2, 4'd0, 4'd0}; // 6 nibbles = 24 bits
//        #200;

        // 3. Another test vector
        Syn = {4'd7, 4'd0, 4'd1, 4'd6, 4'd1, 4'd1, 4'd0};
        #100

        $finish;
    end

    // Monitor and display signals
    initial begin
        $monitor("Time: %0t ns | rst=%b, clk=%b, Syn=%h | sigma=%h",
                  $time, rst, clk, Syn, sigma);
    end

endmodule

